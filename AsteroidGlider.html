<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Asteroid Glider</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Turnstile loader (Invisible mode) -->
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    #gameContainer { width: 100%; max-width: 900px; height: 640px; margin: 0 auto; position: relative; }
    canvas { display: block; width: 100% !important; height: 100% !important; border-radius: 0.5rem;
      background: radial-gradient(ellipse at center, rgba(0,255,153,0.06) 0%, rgba(0,0,0,1) 60%); }
    #uiContainer { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
    #overlayTop { display: flex; width: 100%; justify-content: center; gap: 1rem; }
    #gameOverModal, #startModal {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85); border: 1px solid rgba(16,185,129,0.4);
      border-radius: 0.5rem; min-width: 280px; pointer-events: auto;
    }
    #gameOverModal { display: none; }
    .glass { background: rgba(0,0,0,0.35); border: 1px solid rgba(16,185,129,0.15); border-radius: 0.375rem; }
    .toast { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display:none; }

    #startButton { animation: pulseScale 1.8s ease-in-out infinite; transform-origin: center; will-change: transform; }
    #startButton:hover { transform: scale(1.06); }
    #startButton:active { transform: scale(0.98); }
    @keyframes pulseScale { 0%,100%{transform:scale(1)} 50%{transform:scale(1.06)} }
    @media (prefers-reduced-motion: reduce) { #startButton { animation: none !important; } }
  </style>
</head>
<body class="bg-black">
  <div class="w-screen min-h-screen flex items-center justify-center p-4">
    <div id="gameContainer" class="rounded-lg shadow-xl ring-1 ring-green-400/20">
      <canvas id="gameCanvas"></canvas>

      <div id="uiContainer">
        <div id="overlayTop" class="p-2">
          <div id="hudStack" class="flex flex-col items-center">
            <div id="scoreBoard" class="text-green-400 font-mono p-4 glass">Lvl 1 • Score: 0 • Lasers: 3/5</div>
            <div id="rowNotice" class="text-green-400 font-mono text-sm mt-2 opacity-0 transition-opacity duration-300 select-none glass px-3 py-1 rounded"></div>
          </div>
        </div>
        <div class="flex items-center justify-center p-2">
          <div id="instructions" class="text-green-400 font-mono p-4 glass text-sm opacity-80">
            Use ← → (or A/D) or swipe • Space/tap to shoot • Avoid asteroids • Pass the target to level up.
          </div>
        </div>
      </div>

      <div id="levelToast" class="toast text-green-400 font-mono p-4 glass text-lg">
        LEVEL <span id="toastLevel">2</span>!
      </div>

      <div id="startModal" class="text-green-400 font-mono p-6 text-center">
        <h2 class="text-xl mb-2">Asteroid Glider</h2>
        <p class="mb-4 opacity-80 text-sm">Dodge asteroids, shoot threats, and level up.</p>
        <button id="startButton"
                class="pointer-events-auto border border-green-400/40 px-5 py-2 rounded hover:bg-green-400/10 transition font-mono">
          Start
        </button>
      </div>

      <div id="gameOverModal" class="text-green-400 font-mono p-4 max-w-md">
        <h2 class="text-xl mb-2 text-center">Transmission Lost</h2>
        <p id="finalScore" class="text-center mb-1">Score: 0</p>
        <p id="finalLevel" class="text-center mb-4">Final Level: 1</p>

        <div class="flex flex-col sm:flex-row gap-2 items-stretch sm:items-center justify-center mb-3">
          <input id="playerNameInput" maxlength="24" placeholder="Your name"
                 class="pointer-events-auto bg-black/40 border border-green-400/30 rounded px-3 py-2 outline-none focus:border-green-400/60" />
          <button id="saveScoreButton"
                  class="pointer-events-auto border border-green-400/40 px-4 py-2 rounded hover:bg-green-400/10 transition">
            Save Score
          </button>
        </div>
        <!-- Invisible Turnstile mount target (no visible checkbox) -->
        <div id="cf-container" class="flex justify-center mb-3"><div id="turnstile-target"></div></div>

        <div id="leaderboard" class="glass rounded p-3 max-h-56 overflow-auto mb-3">
          <div class="flex items-center justify-between mb-2">
            <h3 class="text-lg">Leaderboard</h3>
            <span class="text-xs opacity-70">Top 10 (Global)</span>
          </div>
          <ol id="leaderboardList" class="space-y-1 text-sm">
            <li class="opacity-70">Loading…</li>
          </ol>
        </div>

        <div class="flex justify-center pb-2">
          <button id="restartButton"
                  class="pointer-events-auto border border-green-400/40 px-4 py-2 rounded hover:bg-green-400/10 transition font-mono">
            Restart
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===================== GLOBAL LEADERBOARD (GET only) =====================
    const SCORES_API = '/api/scores'; // same-origin GET for leaderboard

    // ===================== SERVER-AUTHORITATIVE SCORING =====================
    const API_BASE = '/api/session';

    // Turnstile (Invisible)
    let turnstileToken = "";
    let turnstileWidgetId = null;
    window.onTurnstileVerified = (token) => { turnstileToken = token || ""; };
    function mountTurnstile(){
      const mount = document.getElementById('turnstile-target');
      if(!mount) return;
      if(window.turnstile){
        turnstileWidgetId = turnstile.render(mount, {
          sitekey: 'YOUR_TURNSTILE_SITE_KEY', // <-- replace with your site key
          size: 'invisible',
          callback: onTurnstileVerified
        });
      } else { setTimeout(mountTurnstile, 300); }
    }
    document.addEventListener('DOMContentLoaded', mountTurnstile);

    // Server session + batching state
    let serverSessionId = '';
    let queuedDodged = 0, queuedShot = 0, queuedLasersFired = 0;
    let lastBatchAtMs = 0;

    async function apiPost(path, body){
      const res = await fetch(path, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'omit',
        body: JSON.stringify(body)
      });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    // ===================== LEADERBOARD UI =====================
    const playerNameInput = document.getElementById('playerNameInput');
    const saveScoreButton = document.getElementById('saveScoreButton');
    const leaderboardList = document.getElementById('leaderboardList');
    let hasSavedThisRun = false;

    function setBoardStatus(text){ if(!leaderboardList) return; leaderboardList.innerHTML = `<li class="opacity-70">${text}</li>`; }
    function esc(s){ return String(s).replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }
    function renderBoard(scores=[]){
      if(!leaderboardList) return;
      if(!scores.length) return setBoardStatus('No scores yet. Be the first!');
      leaderboardList.innerHTML='';
      scores.forEach((e,i)=>{
        const when=new Date(e.date||Date.now()).toLocaleDateString(undefined,{month:'short',day:'numeric'});
        const li=document.createElement('li');
        li.style.display='grid'; li.style.gridTemplateColumns='2rem 1fr auto'; li.style.gap='0.5rem';
        li.innerHTML=`<span class=\"opacity-70\">${i+1}.</span><span class=\"name\">${esc(e.name||'')}</span><span class=\"opacity-80\">Score ${e.score} • L${e.level} • ${when}</span>`;
        leaderboardList.appendChild(li);
      });
    }
    async function refreshLeaderboard(){
      if(!leaderboardList) return;
      setBoardStatus('Loading…');
      try{
        const res=await fetch(SCORES_API,{method:'GET',credentials:'omit'});
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        const {scores}=await res.json(); renderBoard(scores);
      }catch(err){ console.error('Leaderboard load failed:',err); setBoardStatus('Error loading leaderboard.'); }
    }

    async function onSaveScoreGlobal(){
      if(hasSavedThisRun) return;
      const name=(playerNameInput?.value||'').trim();
      if(!name){ playerNameInput?.focus(); playerNameInput.placeholder='Enter a name to save'; return; }
      if(!serverSessionId){ setBoardStatus('Session expired. Restart and try again.'); return; }

      // ensure a fresh token before finalize (invisible)
      if(!turnstileToken && window.turnstile && turnstileWidgetId){ await turnstile.execute(turnstileWidgetId); }
      if(!turnstileToken){ setBoardStatus('Please try again (verification).'); return; }

      saveScoreButton.disabled=true; saveScoreButton.textContent='Saving…';
      try{
        // send any remaining deltas before finalize
        if(serverSessionId && (queuedDodged||queuedShot||queuedLasersFired)){
          const d=queuedDodged, s=queuedShot, l=queuedLasersFired; queuedDodged=queuedShot=queuedLasersFired=0;
          await apiPost(`${API_BASE}/batch`, { sessionId: serverSessionId, dodgedDelta:d, shotDelta:s, lasersFiredDelta:l, levelMax: level });
        }
        const { scores, score:serverScore, level:serverLevel } = await apiPost(`${API_BASE}/finalize`, { sessionId: serverSessionId, name: name.slice(0,24) });
        hasSavedThisRun=true;
        saveScoreButton.textContent='Saved'; saveScoreButton.classList.add('opacity-60');
        finalScoreDisplay.textContent=`Score: ${serverScore}`;
        finalLevelDisplay.textContent=`Final Level: ${serverLevel}`;
        renderBoard(scores);
      }catch(err){ console.error('Save failed:',err); saveScoreButton.disabled=false; saveScoreButton.textContent='Retry Save'; }
      finally{ if(window.turnstile && turnstileWidgetId) turnstile.reset(turnstileWidgetId); turnstileToken=""; }
    }

    // ===================== GAME CODE =====================
    let scene, camera, renderer;
    let player, obstacles=[];
    let gameStarted=false;
    let lanes=[-2.5,0,2.5];
    let currentLane=1;
    let targetX=lanes[currentLane];
    const laneLerp=0.15;

    const SHIP_SPAN=2.1, SHIP_LENGTH=1.1;

    let lasers=[];
    const LASER_MAX=5; let laserAmmo=3;
    const LASER_SPEED=1.6;
    const LASER_SIZE={x:0.08,y:0.08,z:0.9};

    let starField;
    const STAR_COUNT=1500;

    let level=1;
    const baseAsteroidsTarget=10;
    let passedThisLevel=0;
    let targetThisLevel=baseAsteroidsTarget;
    let totalPassed=0;

    let score=0;
    const POINTS_PER_ASTEROID_DODGED = 10;
    const POINTS_PER_ASTEROID_SHOT   = 100;

    const REFERENCE_FPS = 120;

    let speed=0.2;
    let spawnInterval=70;
    let spawnEverySec=spawnInterval/REFERENCE_FPS;
    let spawnTimerSec=0;
    let extraSpawnChance=0.0;

    let phase='play';
    const CLEAR_CORRIDOR_MS=5000;
    let corridorStartTime=0;

    let frame=0, gameOver=false;

    let touchStartX=0, touchStartY=0, touchStartTime=0;
    const SWIPE_THRESHOLD=30, TAP_MAX_TIME=300, TAP_MAX_MOVE=20;

    const gameCanvas=document.getElementById('gameCanvas');
    const gameContainer=document.getElementById('gameContainer');
    const scoreBoard=document.getElementById('scoreBoard');
    const rowNotice=document.getElementById('rowNotice');
    const gameOverModal=document.getElementById('gameOverModal');
    const startModal=document.getElementById('startModal');
    const startButton=document.getElementById('startButton');
    const finalScoreDisplay=document.getElementById('finalScore');
    const finalLevelDisplay=document.getElementById('finalLevel');
    const restartButton=document.getElementById('restartButton');
    const instructions=document.getElementById('instructions');
    const levelToast=document.getElementById('levelToast');
    const toastLevel=document.getElementById('toastLevel');

    const PLAYER_Z=2.2, OBSTACLE_START_Z=-80, DESPAWN_Z=6.0;

    let lastTime=performance.now();

    init();
    animate();

    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0x000000);

      const aspect=gameContainer.clientWidth/gameContainer.clientHeight;
      camera=new THREE.PerspectiveCamera(60,aspect,0.1,1000);
      camera.position.set(0,2.6,PLAYER_Z+7.5);
      camera.lookAt(0,0.5,-10);

      renderer=new THREE.WebGLRenderer({canvas:gameCanvas,antialias:true});
      renderer.setSize(gameContainer.clientWidth,gameContainer.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));

      const ambient=new THREE.AmbientLight(0xffffff,0.6); scene.add(ambient);
      const dir=new THREE.DirectionalLight(0x88ffcc,0.9); dir.position.set(5,10,5); scene.add(dir);

      const g=new THREE.BufferGeometry();
      const starPositions=new Float32Array(STAR_COUNT*3);
      for(let i=0;i<STAR_COUNT;i++){
        starPositions[i*3+0]=(Math.random()-0.5)*60;
        starPositions[i*3+1]=(Math.random()-0.5)*40;
        starPositions[i*3+2]=-Math.random()*200;
      }
      g.setAttribute('position',new THREE.Float32BufferAttribute(starPositions,3));
      const m=new THREE.PointsMaterial({color:0xffffff,size:0.06});
      starField=new THREE.Points(g,m); scene.add(starField);

      player=createShip(true);
      player.position.set(lanes[currentLane],0,PLAYER_Z);
      scene.add(player);

      window.addEventListener('keydown',onKeyDown);
      gameCanvas.addEventListener('touchstart',onTouchStart,{passive:false});
      gameCanvas.addEventListener('touchend',onTouchEnd,{passive:false});

      // Buttons
      startButton.addEventListener('click', ()=>{ startGame().catch(console.error); });
      restartButton.addEventListener('click', ()=>{ restart().catch(console.error); });
      saveScoreButton?.addEventListener('click', onSaveScoreGlobal);

      window.addEventListener('resize',onResize);

      updateHud();
    }

    async function startGame(){
      gameStarted=true; gameOver=false;
      lanes=[-2.5,0,2.5]; currentLane=1; targetX=lanes[currentLane];
      level=1; passedThisLevel=0; targetThisLevel=baseAsteroidsTarget; totalPassed=0;
      score=0;
      lasers.forEach(L=>scene.remove(L)); lasers=[];
      obstacles.forEach(o=>scene.remove(o)); obstacles=[];
      laserAmmo=3;

      speed=0.2; spawnInterval=70; spawnEverySec=spawnInterval/REFERENCE_FPS; spawnTimerSec=0;
      extraSpawnChance=0.0;

      phase='play'; corridorStartTime=0; frame=0;
      player.position.set(lanes[currentLane],0,PLAYER_Z); player.rotation.z=0;

      lastTime=performance.now();

      // ---- server session start ----
      if(!turnstileToken && window.turnstile && turnstileWidgetId){ await turnstile.execute(turnstileWidgetId); }
      const sess = await apiPost(`${API_BASE}/start`, { turnstileToken });
      serverSessionId = sess.sessionId || '';
      turnstileToken = '';
      queuedDodged=queuedShot=queuedLasersFired=0; lastBatchAtMs=0;

      instructions.style.display='block';
      startModal.style.display='none';
      updateHud();
    }

    function createShip(isPlayer=false){
      const group=new THREE.Group();
      const hullMat=new THREE.MeshPhongMaterial({color:0x2a2f33,emissive:0x0b0f10,shininess:80,flatShading:true});
      const glowMat=new THREE.MeshPhongMaterial({color:isPlayer?0x00ff99:0xff6666,emissive:isPlayer?0x006644:0x661111,emissiveIntensity:0.7});
      const halfSpan=SHIP_SPAN/2, L=SHIP_LENGTH;

      const s=new THREE.Shape();
      s.moveTo(-halfSpan,0.00);
      s.lineTo(-halfSpan*0.45,0.20*L);
      s.lineTo(-halfSpan*0.17,0.28*L);
      s.lineTo(0,0.30*L);
      s.lineTo(halfSpan*0.17,0.28*L);
      s.lineTo(halfSpan*0.45,0.20*L);
      s.lineTo(halfSpan,0.00);
      s.lineTo(halfSpan*0.55,-0.10*L);
      s.lineTo(halfSpan*0.20,-0.18*L);
      s.lineTo(0,-0.22*L);
      s.lineTo(-halfSpan*0.20,-0.18*L);
      s.lineTo(-halfSpan*0.55,-0.10*L);
      s.closePath();

      const wingGeo=new THREE.ExtrudeGeometry(s,{depth:0.14,bevelEnabled:false,curveSegments:4});
      wingGeo.rotateX(Math.PI/2); wingGeo.translate(0,0.05,0);
      group.add(new THREE.Mesh(wingGeo,hullMat));

      const canopy=new THREE.Mesh(new THREE.CylinderGeometry(0.10,0.10,0.55,12),new THREE.MeshPhongMaterial({color:0x88ffee,transparent:true,opacity:0.5}));
      canopy.rotation.x=Math.PI/2; canopy.position.set(0,0.10,0.18*L); group.add(canopy);

      const stripGeo=new THREE.BoxGeometry(0.9,0.02,0.02);
      const leftStrip=new THREE.Mesh(stripGeo,glowMat); leftStrip.position.set(-halfSpan*0.6,0.06,0.20*L); leftStrip.rotation.y=-Math.PI*0.05;
      const rightStrip=leftStrip.clone(); rightStrip.position.x=halfSpan*0.6; rightStrip.rotation.y=Math.PI*0.05;
      group.add(leftStrip,rightStrip);

      const exhaust=new THREE.Mesh(new THREE.CylinderGeometry(0.10,0.02,0.24,10),glowMat);
      exhaust.rotation.x=Math.PI/2; exhaust.position.set(0,0.02,-0.20*L); group.add(exhaust);

      return group;
    }

    function createAsteroid(size=0.7){
      const geo=new THREE.DodecahedronGeometry(size,0);
      geo.vertices?.forEach?.(v=>{ v.x*=0.8+Math.random()*0.5; v.y*=0.8+Math.random()*0.5; v.z*=0.8+Math.random()*0.5; });
      const mesh=new THREE.Mesh(geo,new THREE.MeshPhongMaterial({color:0x8b6b4e,flatShading:true}));
      mesh.rotation.set(Math.random()*Math.PI,Math.random()*Math.PI,Math.random()*Math.PI);
      mesh.userData.r=size*0.50;
      return mesh;
    }

    function createLaser(){
      const laser=new THREE.Mesh(
        new THREE.BoxGeometry(LASER_SIZE.x,LASER_SIZE.y,LASER_SIZE.z),
        new THREE.MeshPhongMaterial({color:0x00ff99,emissive:0x006644,emissiveIntensity:0.9})
      );
      laser.position.set(player.position.x,0,PLAYER_Z-0.55);
      laser.userData.prevZ = laser.position.z;
      scene.add(laser); return laser;
    }

    function onKeyDown(e){
      if(!gameStarted||gameOver) return;
      let newLane=currentLane;
      if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') newLane=Math.max(0,currentLane-1);
      if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') newLane=Math.min(lanes.length-1,currentLane+1);
      if(e.code==='Space'||e.key===' '||e.key==='Spacebar') shootLaser();
      if(newLane!==currentLane){ currentLane=newLane; targetX=lanes[currentLane]; }
    }
    function onTouchStart(ev){ if(!gameStarted||gameOver) return; ev.preventDefault(); const t=ev.touches[0]; touchStartX=t.clientX; touchStartY=t.clientY; touchStartTime=performance.now(); }
    function onTouchEnd(ev){
      if(!gameStarted||gameOver) return; ev.preventDefault();
      const t=ev.changedTouches[0]; const dx=t.clientX-touchStartX, dy=t.clientY-touchStartY, dist=Math.hypot(dx,dy), dt=performance.now()-touchStartTime;
      if(Math.abs(dx)>=SWIPE_THRESHOLD && Math.abs(dx)>=Math.abs(dy)){
        let newLane=currentLane; if(dx<0) newLane=Math.max(0,currentLane-1); if(dx>0) newLane=Math.min(lanes.length-1,currentLane+1);
        if(newLane!==currentLane){ currentLane=newLane; targetX=lanes[currentLane]; } return; }
      if(dt<=TAP_MAX_TIME && dist<=TAP_MAX_MOVE) shootLaser();
    }
    function shootLaser(){ if(laserAmmo<=0) return; lasers.push(createLaser()); laserAmmo--; queuedLasersFired++; updateHud(); }

    function getPlayerRadius(){ const spacing=lanes.length>=2?Math.abs(lanes[1]-lanes[0]):2.5; const width=Math.min(SHIP_SPAN,spacing*0.72); return width*0.32; }
    function clamp01(t){ return t<0?0:t>1?1:t; }
    function distPointToSegment2D(px,pz,x0,z0,x1,z1){ const vx=x1-x0, vz=z1-z0; const wx=px-x0, wz=pz-z0; const vv=vx*vx+vz*vz; const t = vv>0 ? clamp01((wx*vx+wz*vz)/vv) : 0; const dx=px-(x0+vx*t), dz=pz-(z0+vz*t); return Math.hypot(dx,dz); }

    function animate(){
      requestAnimationFrame(animate);
      const now=performance.now(); let dtSec=(now-lastTime)/1000; lastTime=now; if(dtSec>0.1) dtSec=0.1; const dtMul = dtSec * REFERENCE_FPS;

      updateStars(dtMul);

      if(gameStarted && !gameOver){
        const lerpFactor=1 - Math.pow(1 - laneLerp, dtMul);
        player.position.x += (targetX - player.position.x) * lerpFactor;
        const diff=targetX - player.position.x; player.rotation.z = THREE.MathUtils.clamp(diff*0.12,-0.2,0.2);

        frame++;
        if(phase==='play'){
          spawnTimerSec += dtSec; while(spawnTimerSec >= spawnEverySec){ spawnWave(); spawnTimerSec -= spawnEverySec; }
        } else if(phase==='transition_wait_clear'){ if(obstacles.length===0) startClearCorridor(); }
        else if(phase==='transition_corridor'){ if(performance.now()-corridorStartTime>=CLEAR_CORRIDOR_MS) phase='play'; }

        updateLasers(dtMul); updateObstacles(dtMul);

        // ---- batch send approx every 800ms ----
        if(serverSessionId){
          if(now - lastBatchAtMs > 800 && (queuedDodged||queuedShot||queuedLasersFired)){
            const d=queuedDodged, s=queuedShot, l=queuedLasersFired; queuedDodged=queuedShot=queuedLasersFired=0; lastBatchAtMs = now;
            apiPost(`${API_BASE}/batch`, { sessionId: serverSessionId, dodgedDelta:d, shotDelta:s, lasersFiredDelta:l, levelMax: level })
              .catch(err=>{ console.error('batch failed',err); queuedDodged+=d; queuedShot+=s; queuedLasersFired+=l; });
          }
        }
      }

      camera.position.x = THREE.MathUtils.lerp(camera.position.x, player.position.x*0.5, 0.08);
      camera.lookAt(player.position.x,0.4,-10);
      renderer.render(scene,camera);
    }

    function spawnWave(){ spawnAsteroidInLane(); if(Math.random()<extraSpawnChance) spawnAsteroidInLane(); }
    function spawnAsteroidInLane(){ const baseSize=0.6 + Math.min((level-1)*0.08,0.8); const size=baseSize*(0.85+Math.random()*0.3); const rock=createAsteroid(size); const laneIndex=Math.floor(Math.random()*lanes.length); rock.position.set(lanes[laneIndex],0,OBSTACLE_START_Z); if(Math.random()<Math.min(0.05+level*0.01,0.25)) rock.userData.fast=true; scene.add(rock); obstacles.push(rock); }

    function updateLasers(dtMul){
      for(let li=lasers.length-1; li>=0; li--){
        const L=lasers[li]; const prevZ = L.userData.prevZ ?? L.position.z; L.position.z -= LASER_SPEED * dtMul;
        if(L.position.z < OBSTACLE_START_Z - 20){ scene.remove(L); lasers.splice(li,1); continue; }
        let hitHandled=false;
        for(let oi=obstacles.length-1; oi>=0; oi--){
          const o=obstacles[oi]; const xL=L.position.x, xO=o.position.x; const dx=xL-xO;
          const zL0=prevZ, zL1=L.position.z; const zO0=o.position.z; const zSpeedO=(o.userData.fast? speed*1.4 : speed) * dtMul; const zO1=zO0+zSpeedO;
          const a=zL0 - zO0; const b=(zL1 - zL0) - (zO1 - zO0); const tStar = b!==0 ? clamp01(-a/b) : 0; const dzAtMin = a + b*tStar;
          const effR = (o.userData.r ?? 0.5) + (LASER_SIZE.z*0.5) + 0.12; const hit = (dx*dx + dzAtMin*dzAtMin) <= (effR*effR);
          if(hit){ scene.remove(o); obstacles.splice(oi,1); scene.remove(L); lasers.splice(li,1); hitHandled=true; score += POINTS_PER_ASTEROID_SHOT; passedThisLevel++; totalPassed++; queuedShot++; if(phase==='play' && passedThisLevel>=targetThisLevel) beginLevelTransition(); updateHud(); break; }
        }
        if(!hitHandled){ L.userData.prevZ = L.position.z; }
      }
    }

    function updateObstacles(dtMul){
      for(let i=obstacles.length-1; i>=0; i--){
        const o=obstacles[i]; const zSpeed=(o.userData.fast? speed*1.4 : speed) * dtMul; const z0=o.position.z; const z1=z0+zSpeed;
        const pX=player.position.x, pZ=player.position.z; const dist=distPointToSegment2D(pX,pZ,o.position.x,z0,o.position.x,z1);
        const pR=getPlayerRadius(); const oR=(o.userData.r ?? 0.5); const GRACE=0.06;
        if(dist <= Math.max(0, pR + oR - GRACE)) return endGame();
        o.position.z = z1; o.rotation.x += (0.01 + speed*0.05) * dtMul; o.rotation.y += (0.02 + speed*0.05) * dtMul;
        if(o.position.z > DESPAWN_Z){ scene.remove(o); obstacles.splice(i,1); score += POINTS_PER_ASTEROID_DODGED; passedThisLevel++; totalPassed++; queuedDodged++; if(phase==='play' && passedThisLevel>=targetThisLevel) beginLevelTransition(); updateHud(); }
      }
    }

    function updateStars(dtMul){ const pos=starField.geometry.attributes.position.array; for(let i=0;i<STAR_COUNT;i++){ const idx=i*3+2; pos[idx] += speed * 1.5 * dtMul; if(pos[idx]>5){ pos[idx] = -200 - Math.random()*100; pos[i*3+0] = (Math.random()-0.5)*60; pos[i*3+1] = (Math.random()-0.5)*40; } } starField.geometry.attributes.position.needsUpdate=true; }

    function updateHud(){ scoreBoard.textContent=`Lvl ${level} • Score: ${score} • Lasers: ${laserAmmo}/${LASER_MAX}`; }
    function showRowNotice(text){ rowNotice.textContent=text; rowNotice.classList.remove('opacity-0'); rowNotice.classList.add('opacity-100'); if(rowNotice._timer) clearTimeout(rowNotice._timer); rowNotice._timer=setTimeout(()=>{ rowNotice.classList.add('opacity-0'); rowNotice.classList.remove('opacity-100'); },1400); }
    function beginLevelTransition(){ phase='transition_wait_clear'; }

    function nearestLaneIndex(x,arr=lanes){ let idx=0,best=Infinity; for(let i=0;i<arr.length;i++){ const d=Math.abs(arr[i]-x); if(d<best){best=d; idx=i;} } return idx; }

    function startClearCorridor(){
      level++; passedThisLevel=0; targetThisLevel=baseAsteroidsTarget + (level-1)*10; laserAmmo=Math.min(LASER_MAX,laserAmmo+1);
      toastLevel.textContent=level; levelToast.style.display='block'; setTimeout(()=>{ levelToast.style.display='none'; },1000);
      const prevX=player.position.x; let rowsAdded=0;
      if(level===4){ lanes=[-5,-2.5,0,2.5,5]; rowsAdded=2; }
      else if(level===10){ lanes=[-7.5,-5,-2.5,0,2.5,5,7.5]; rowsAdded=2; }
      if(rowsAdded>0){ showRowNotice(`+${rowsAdded} Rows added`); currentLane=nearestLaneIndex(prevX,lanes); targetX=lanes[currentLane]; } else { targetX=lanes[currentLane]; }
      applyLevelDifficulty(); corridorStartTime=performance.now(); phase='transition_corridor'; updateHud();
    }

    function applyLevelDifficulty(){ const increments=Math.floor((level-1)/3); speed=Math.min(0.2 + increments*0.015, 0.75); spawnInterval=Math.max(24, 70 - (level-1)*4); spawnEverySec=spawnInterval/REFERENCE_FPS; extraSpawnChance=Math.min(0.05 + (level-1)*0.03, 0.45); }

    function endGame(){ gameOver=true; finalScoreDisplay.textContent=`Score: ${score}`; finalLevelDisplay.textContent=`Final Level: ${level}`; hasSavedThisRun=false; if(saveScoreButton){ saveScoreButton.disabled=false; saveScoreButton.textContent='Save Score'; saveScoreButton.classList.remove('opacity-60'); } refreshLeaderboard(); gameOverModal.style.display='block'; instructions.style.display='none'; }

    async function restart(){ gameOverModal.style.display='none'; await startGame(); }

    function onResize(){ const w=gameContainer.clientWidth, h=gameContainer.clientHeight; camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); }
  </script>
</body>
</html>
