<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Asteroid Glider</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    #gameContainer { width: 100%; max-width: 900px; height: 640px; margin: 0 auto; position: relative; }
    canvas { display: block; width: 100% !important; height: 100% !important; border-radius: 0.5rem;
      background: radial-gradient(ellipse at center, rgba(0,255,153,0.06) 0%, rgba(0,0,0,1) 60%); }
    #uiContainer { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
    #overlayTop { display: flex; width: 100%; justify-content: center; gap: 1rem; }
    #gameOverModal, #startModal {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85); border: 1px solid rgba(16,185,129,0.4);
      border-radius: 0.5rem; min-width: 280px; pointer-events: auto;
    }
    #gameOverModal { display: none; }
    .glass { background: rgba(0,0,0,0.35); border: 1px solid rgba(16,185,129,0.15); border-radius: 0.375rem; }
    .toast { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display:none; }

    /* --- Start button subtle pulse/zoom --- */
    #startButton {
      animation: pulseScale 1.8s ease-in-out infinite;
      transform-origin: center;
      will-change: transform;
    }
    #startButton:hover { transform: scale(1.06); }
    #startButton:active { transform: scale(0.98); }
    @keyframes pulseScale {
      0%, 100% { transform: scale(1); }
      50%      { transform: scale(1.06); }
    }
    @media (prefers-reduced-motion: reduce) {
      #startButton { animation: none !important; }
    }
  </style>
</head>
<body class="bg-black">
  <div class="w-screen min-h-screen flex items-center justify-center p-4">
    <div id="gameContainer" class="rounded-lg shadow-xl ring-1 ring-green-400/20">
      <canvas id="gameCanvas"></canvas>

      <div id="uiContainer">
        <div id="overlayTop" class="p-2">
          <div id="hudStack" class="flex flex-col items-center">
            <div id="scoreBoard" class="text-green-400 font-mono p-4 glass">Lvl 1 • Score: 0 • Lasers: 3/5</div>
            <div id="rowNotice" class="text-green-400 font-mono text-sm mt-2 opacity-0 transition-opacity duration-300 select-none glass px-3 py-1 rounded"></div>
          </div>
        </div>
        <div class="flex items-center justify-center p-2">
          <div id="instructions" class="text-green-400 font-mono p-4 glass text-sm opacity-80">
            Use ← → (or A/D) or swipe • Space/tap to shoot • Avoid asteroids • Pass the target to level up.
          </div>
        </div>
      </div>

      <!-- Level-up toast (centered) -->
      <div id="levelToast" class="toast text-green-400 font-mono p-4 glass text-lg">
        LEVEL <span id="toastLevel">2</span>!
      </div>

      <!-- Start screen -->
      <div id="startModal" class="text-green-400 font-mono p-6 text-center">
        <h2 class="text-xl mb-2">Asteroid Glider</h2>
        <p class="mb-4 opacity-80 text-sm">Dodge asteroids, shoot threats, and level up.</p>
        <button id="startButton"
                class="pointer-events-auto border border-green-400/40 px-5 py-2 rounded hover:bg-green-400/10 transition font-mono">
          Start
        </button>
      </div>

      <!-- Game over -->
      <div id="gameOverModal" class="text-green-400 font-mono p-4">
        <h2 class="text-xl mb-2 text-center">Transmission Lost</h2>
        <p id="finalScore" class="text-center mb-1">Score: 0</p>
        <p id="finalLevel" class="text-center mb-4">Final Level: 1</p>
        <div class="flex justify-center pb-2">
          <button id="restartButton"
                  class="pointer-events-auto border border-green-400/40 px-4 py-2 rounded hover:bg-green-400/10 transition font-mono">
            Restart
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ======= Core setup =======
    let scene, camera, renderer;
    let player, obstacles = [];
    let gameStarted = false;
    let lanes = [-2.5, 0, 2.5];
    let currentLane = 1;
    let targetX = lanes[currentLane];
    const laneLerp = 0.15;

    // Ship size (fits within one lane)
    const SHIP_SPAN = 2.1;
    const SHIP_LENGTH = 1.1;

    // Lasers
    let lasers = [];
    const LASER_MAX = 5;
    let laserAmmo = 3;
    const LASER_SPEED = 1.6;
    const LASER_SIZE = { x: 0.08, y: 0.08, z: 0.9 };

    let starField;
    const STAR_COUNT = 1500;

    // Leveling
    let level = 1;
    const baseAsteroidsTarget = 10;
    let passedThisLevel = 0;
    let targetThisLevel = baseAsteroidsTarget;
    let totalPassed = 0;

    // Score
    let score = 0;
    const POINTS_PER_ASTEROID = 10;

    // Difficulty knobs
    let speed = 0.2;
    let spawnInterval = 70;
    let extraSpawnChance = 0.0;

    // Phases
    let phase = 'play';
    const CLEAR_CORRIDOR_MS = 5000;
    let corridorStartTime = 0;

    let frame = 0;
    let gameOver = false;

    // Touch: swipe vs tap
    let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
    const SWIPE_THRESHOLD = 30;
    const TAP_MAX_TIME = 300;
    const TAP_MAX_MOVE = 20;

    const gameCanvas = document.getElementById('gameCanvas');
    const gameContainer = document.getElementById('gameContainer');
    const scoreBoard = document.getElementById('scoreBoard');
    const rowNotice = document.getElementById('rowNotice');
    const gameOverModal = document.getElementById('gameOverModal');
    const startModal = document.getElementById('startModal');
    const startButton = document.getElementById('startButton');
    const finalScoreDisplay = document.getElementById('finalScore');
    const finalLevelDisplay = document.getElementById('finalLevel');
    const restartButton = document.getElementById('restartButton');
    const instructions = document.getElementById('instructions');
    const levelToast = document.getElementById('levelToast');
    const toastLevel = document.getElementById('toastLevel');

    const PLAYER_Z = 2.2;
    const OBSTACLE_START_Z = -80;
    const DESPAWN_Z = 6.0;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const aspect = gameContainer.clientWidth / gameContainer.clientHeight;
      camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
      camera.position.set(0, 2.6, PLAYER_Z + 7.5);
      camera.lookAt(0, 0.5, -10);

      renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
      renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // Lights
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0x88ffcc, 0.9);
      dir.position.set(5, 10, 5);
      scene.add(dir);

      // Stars
      const g = new THREE.BufferGeometry();
      const starPositions = new Float32Array(STAR_COUNT * 3);
      for (let i = 0; i < STAR_COUNT; i++) {
        starPositions[i * 3 + 0] = (Math.random() - 0.5) * 60;
        starPositions[i * 3 + 1] = (Math.random() - 0.5) * 40;
        starPositions[i * 3 + 2] = -Math.random() * 200;
      }
      g.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
      const m = new THREE.PointsMaterial({ color: 0xffffff, size: 0.06 });
      starField = new THREE.Points(g, m);
      scene.add(starField);

      // Player
      player = createShip(true);
      player.position.set(lanes[currentLane], 0, PLAYER_Z);
      scene.add(player);

      // Controls
      window.addEventListener('keydown', onKeyDown);
      gameCanvas.addEventListener('touchstart', onTouchStart, { passive: false });
      gameCanvas.addEventListener('touchend', onTouchEnd, { passive: false });
      restartButton.addEventListener('click', restart);
      startButton.addEventListener('click', startGame);
      window.addEventListener('resize', onResize);

      updateHud();
    }

    function startGame() {
      gameStarted = true;
      gameOver = false;
      lanes = [-2.5, 0, 2.5];
      currentLane = 1; targetX = lanes[currentLane];
      level = 1; passedThisLevel = 0; targetThisLevel = baseAsteroidsTarget; totalPassed = 0;
      score = 0;
      lasers.forEach(L => scene.remove(L)); lasers = [];
      obstacles.forEach(o => scene.remove(o)); obstacles = [];
      laserAmmo = 3;
      speed = 0.2; spawnInterval = 70; extraSpawnChance = 0.0;
      phase = 'play'; corridorStartTime = 0; frame = 0;
      player.position.set(lanes[currentLane], 0, PLAYER_Z); player.rotation.z = 0;

      instructions.style.display = 'block';
      startModal.style.display = 'none';

      updateHud();
    }

    // ======= B-2–style ship (lane-sized) =======
    function createShip(isPlayer=false) {
      const group = new THREE.Group();

      const hullMat = new THREE.MeshPhongMaterial({
        color: 0x2a2f33, emissive: 0x0b0f10, shininess: 80, flatShading: true
      });
      const glowMat = new THREE.MeshPhongMaterial({
        color: isPlayer ? 0x00ff99 : 0xff6666, emissive: isPlayer ? 0x006644 : 0x661111, emissiveIntensity: 0.7
      });

      const halfSpan = SHIP_SPAN / 2;
      const L = SHIP_LENGTH;

      const s = new THREE.Shape();
      s.moveTo(-halfSpan, 0.00);
      s.lineTo(-halfSpan * 0.45,  0.20*L);
      s.lineTo(-halfSpan * 0.17,  0.28*L);
      s.lineTo(0,                 0.30*L);
      s.lineTo( halfSpan * 0.17,  0.28*L);
      s.lineTo( halfSpan * 0.45,  0.20*L);
      s.lineTo( halfSpan,         0.00);
      s.lineTo( halfSpan * 0.55, -0.10*L);
      s.lineTo( halfSpan * 0.20, -0.18*L);
      s.lineTo( 0,               -0.22*L);
      s.lineTo(-halfSpan * 0.20, -0.18*L);
      s.lineTo(-halfSpan * 0.55, -0.10*L);
      s.closePath();

      const wingGeo = new THREE.ExtrudeGeometry(s, { depth: 0.14, bevelEnabled: false, curveSegments: 4 });
      wingGeo.rotateX(Math.PI / 2);
      wingGeo.translate(0, 0.05, 0);
      const wing = new THREE.Mesh(wingGeo, hullMat);
      group.add(wing);

      const canopyGeo = new THREE.CylinderGeometry(0.10, 0.10, 0.55, 12);
      const canopyMat = new THREE.MeshPhongMaterial({ color: 0x88ffee, transparent: true, opacity: 0.5 });
      const canopy = new THREE.Mesh(canopyGeo, canopyMat);
      canopy.rotation.x = Math.PI / 2;
      canopy.position.set(0, 0.10, 0.18*L);
      group.add(canopy);

      const stripGeo = new THREE.BoxGeometry(0.9, 0.02, 0.02);
      const leftStrip = new THREE.Mesh(stripGeo, glowMat);
      leftStrip.position.set(-halfSpan * 0.6, 0.06, 0.20*L);
      leftStrip.rotation.y = -Math.PI * 0.05;
      const rightStrip = leftStrip.clone();
      rightStrip.position.x = halfSpan * 0.6;
      rightStrip.rotation.y =  Math.PI * 0.05;
      group.add(leftStrip, rightStrip);

      const exhaustGeo = new THREE.CylinderGeometry(0.10, 0.02, 0.24, 10);
      const exhaust = new THREE.Mesh(exhaustGeo, glowMat);
      exhaust.rotation.x = Math.PI / 2;
      exhaust.position.set(0, 0.02, -0.20*L);
      group.add(exhaust);

      return group;
    }

    function createAsteroid(size=0.7) {
      const geo = new THREE.DodecahedronGeometry(size, 0);
      geo.vertices?.forEach?.(v => {
        v.x *= 0.8 + Math.random()*0.5;
        v.y *= 0.8 + Math.random()*0.5;
        v.z *= 0.8 + Math.random()*0.5;
      });
      const mat = new THREE.MeshPhongMaterial({ color: 0x8b6b4e, flatShading: true });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
      return mesh;
    }

    function createLaser() {
      const geo = new THREE.BoxGeometry(LASER_SIZE.x, LASER_SIZE.y, LASER_SIZE.z);
      const mat = new THREE.MeshPhongMaterial({ color: 0x00ff99, emissive: 0x006644, emissiveIntensity: 0.9 });
      const laser = new THREE.Mesh(geo, mat);
      laser.position.set(player.position.x, 0, PLAYER_Z - 0.55);
      scene.add(laser);
      return laser;
    }

    // ======= Input (disabled until gameStarted) =======
    function onKeyDown(e) {
      if (!gameStarted || gameOver) return;
      let newLane = currentLane;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') newLane = Math.max(0, currentLane - 1);
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') newLane = Math.min(lanes.length - 1, currentLane + 1);
      if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') shootLaser();
      if (newLane !== currentLane) { currentLane = newLane; targetX = lanes[currentLane]; }
    }

    function onTouchStart(ev) {
      if (!gameStarted || gameOver) return;
      ev.preventDefault();
      const t = ev.touches[0];
      touchStartX = t.clientX; touchStartY = t.clientY;
      touchStartTime = performance.now();
    }

    function onTouchEnd(ev) {
      if (!gameStarted || gameOver) return;
      ev.preventDefault();
      const t = ev.changedTouches[0];
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const dist = Math.hypot(dx, dy);
      const dt = performance.now() - touchStartTime;

      if (Math.abs(dx) >= SWIPE_THRESHOLD && Math.abs(dx) >= Math.abs(dy)) {
        let newLane = currentLane;
        if (dx < 0) newLane = Math.max(0, currentLane - 1);
        if (dx > 0) newLane = Math.min(lanes.length - 1, currentLane + 1);
        if (newLane !== currentLane) { currentLane = newLane; targetX = lanes[currentLane]; }
        return;
      }
      if (dt <= TAP_MAX_TIME && dist <= TAP_MAX_MOVE) shootLaser();
    }

    function shootLaser() {
      if (laserAmmo <= 0) return;
      const laser = createLaser();
      lasers.push(laser);
      laserAmmo--;
      updateHud();
    }

    // ======= Player hitbox (smaller than a lane) =======
    function computePlayerHitbox() {
      const spacing = lanes.length >= 2 ? Math.abs(lanes[1] - lanes[0]) : 2.5;
      const width = Math.min(SHIP_SPAN, spacing * 0.80);
      const halfW = width / 2;
      const halfL = 0.35;
      const halfH = 0.12;
      const cx = player.position.x, cy = player.position.y, cz = player.position.z;
      const min = new THREE.Vector3(cx - halfW, cy - halfH, cz - halfL);
      const max = new THREE.Vector3(cx + halfW, cy + halfH, cz + halfL);
      return new THREE.Box3(min, max);
    }

    // ======= Game Loop =======
    function animate() {
      requestAnimationFrame(animate);

      // Title background starfield animates always
      updateStars();

      if (gameStarted && !gameOver) {
        player.position.x = THREE.MathUtils.lerp(player.position.x, targetX, laneLerp);
        const diff = targetX - player.position.x;
        player.rotation.z = THREE.MathUtils.clamp(diff * 0.12, -0.2, 0.2);

        frame++;
        if (phase === 'play') {
          if (frame % spawnInterval === 0) spawnWave();
        } else if (phase === 'transition_wait_clear') {
          if (obstacles.length === 0) startClearCorridor();
        } else if (phase === 'transition_corridor') {
          if (performance.now() - corridorStartTime >= CLEAR_CORRIDOR_MS) phase = 'play';
        }

        updateLasers();
        updateObstacles();
      }

      camera.position.x = THREE.MathUtils.lerp(camera.position.x, player.position.x * 0.5, 0.08);
      camera.lookAt(player.position.x, 0.4, -10);

      renderer.render(scene, camera);
    }

    function spawnWave() {
      spawnAsteroidInLane();
      if (Math.random() < extraSpawnChance) spawnAsteroidInLane();
    }

    function spawnAsteroidInLane() {
      const baseSize = 0.6 + Math.min((level - 1) * 0.08, 0.8);
      const size = baseSize * (0.85 + Math.random() * 0.3);
      const rock = createAsteroid(size);

      const laneIndex = Math.floor(Math.random() * lanes.length);
      rock.position.set(lanes[laneIndex], 0, OBSTACLE_START_Z);

      if (Math.random() < Math.min(0.05 + level * 0.01, 0.25)) rock.userData.fast = true;
      rock.userData.r = size * 0.9;

      scene.add(rock);
      obstacles.push(rock);
    }

    function updateLasers() {
      for (let li = lasers.length - 1; li >= 0; li--) {
        const L = lasers[li];
        L.position.z -= LASER_SPEED;

        if (L.position.z < OBSTACLE_START_Z - 20) {
          scene.remove(L); lasers.splice(li, 1); continue;
        }

        const laserBox = new THREE.Box3().setFromObject(L);
        for (let oi = obstacles.length - 1; oi >= 0; oi--) {
          const o = obstacles[oi];
          const oBox = new THREE.Box3().setFromObject(o);
          const shrink = 0.1;
          oBox.min.x += shrink; oBox.max.x -= shrink;
          oBox.min.y += shrink; oBox.max.y -= shrink;

          if (laserBox.intersectsBox(oBox)) {
            scene.remove(o); obstacles.splice(oi, 1);
            scene.remove(L); lasers.splice(li, 1);
            score += POINTS_PER_ASTEROID;
            passedThisLevel++; totalPassed++;
            if (phase === 'play' && passedThisLevel >= targetThisLevel) beginLevelTransition();
            updateHud();
            break;
          }
        }
      }
    }

    function updateObstacles() {
      const playerBox = computePlayerHitbox();
      const shrink = 0.1;

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        const zSpeed = o.userData.fast ? speed * 1.4 : speed;
        o.position.z += zSpeed;

        o.rotation.x += 0.01 + speed * 0.05;
        o.rotation.y += 0.02 + speed * 0.05;

        const box = new THREE.Box3().setFromObject(o);
        box.min.x += shrink; box.max.x -= shrink;
        box.min.y += shrink; box.max.y -= shrink;

        if (playerBox.intersectsBox(box)) {
          if (Math.abs(player.position.z - o.position.z) < 1.3) return endGame();
        }

        if (o.position.z > DESPAWN_Z) {
          scene.remove(o);
          obstacles.splice(i, 1);
          score += POINTS_PER_ASTEROID;
          passedThisLevel++; totalPassed++;
          if (phase === 'play' && passedThisLevel >= targetThisLevel) beginLevelTransition();
          updateHud();
        }
      }
    }

    function updateStars() {
      const pos = starField.geometry.attributes.position.array;
      for (let i = 0; i < STAR_COUNT; i++) {
        const idx = i * 3 + 2;
        pos[idx] += speed * 1.5;
        if (pos[idx] > 5) {
          pos[idx] = -200 - Math.random() * 100;
          pos[i * 3 + 0] = (Math.random() - 0.5) * 60;
          pos[i * 3 + 1] = (Math.random() - 0.5) * 40;
        }
      }
      starField.geometry.attributes.position.needsUpdate = true;
    }

    // ======= Leveling & UI =======
    function updateHud() {
      scoreBoard.textContent = `Lvl ${level} • Score: ${score} • Lasers: ${laserAmmo}/${LASER_MAX}`;
    }

    function showRowNotice(text) {
      rowNotice.textContent = text;
      rowNotice.classList.remove('opacity-0');
      rowNotice.classList.add('opacity-100');
      if (rowNotice._timer) clearTimeout(rowNotice._timer);
      rowNotice._timer = setTimeout(() => {
        rowNotice.classList.add('opacity-0');
        rowNotice.classList.remove('opacity-100');
      }, 1400);
    }

    function beginLevelTransition() { phase = 'transition_wait_clear'; }

    function startClearCorridor() {
      level++;
      passedThisLevel = 0;
      targetThisLevel = baseAsteroidsTarget + (level - 1) * 10;

      laserAmmo = Math.min(LASER_MAX, laserAmmo + 1);

      toastLevel.textContent = level;
      levelToast.style.display = 'block';
      setTimeout(() => { levelToast.style.display = 'none'; }, 1000);

      let rowsAdded = 0;
      if (level === 4) { lanes = [-5, -2.5, 0, 2.5, 5]; rowsAdded = 2; }
      else if (level === 10) { lanes = [-7.5, -5, -2.5, 0, 2.5, 5, 7.5]; rowsAdded = 2; }
      if (rowsAdded > 0) showRowNotice(`+${rowsAdded} Rows added`);

      currentLane = Math.floor(lanes.length / 2);
      targetX = lanes[currentLane];
      player.position.x = targetX;

      applyLevelDifficulty();

      corridorStartTime = performance.now();
      phase = 'transition_corridor';

      updateHud();
    }

    // Speed increases every 3 levels (Δ=0.015 each bump, cap 0.75)
    function applyLevelDifficulty() {
      const increments = Math.floor((level - 1) / 3);
      speed = Math.min(0.2 + increments * 0.015, 0.75);
      // other knobs still scale per level
      spawnInterval = Math.max(24, 70 - (level - 1) * 4);
      extraSpawnChance = Math.min(0.05 + (level - 1) * 0.03, 0.45);
    }

    function endGame() {
      gameOver = true;
      finalScoreDisplay.textContent = `Score: ${score}`;
      finalLevelDisplay.textContent = `Final Level: ${level}`;
      gameOverModal.style.display = 'block';
      instructions.style.display = 'none';
    }

    function restart() {
      gameStarted = true;
      level = 1; passedThisLevel = 0; targetThisLevel = baseAsteroidsTarget; totalPassed = 0;
      score = 0;

      laserAmmo = 3;
      lasers.forEach(L => scene.remove(L)); lasers = [];

      speed = 0.2; spawnInterval = 70; extraSpawnChance = 0.0;

      phase = 'play';
      corridorStartTime = 0;

      frame = 0; gameOver = false;

      lanes = [-2.5, 0, 2.5];
      currentLane = 1; targetX = lanes[currentLane];
      player.position.set(lanes[currentLane], 0, PLAYER_Z);
      player.rotation.z = 0;

      obstacles.forEach(o => scene.remove(o)); obstacles = [];

      const pos = starField.geometry.attributes.position.array;
      for (let i = 0; i < STAR_COUNT; i++) {
        pos[i * 3 + 0] = (Math.random() - 0.5) * 60;
        pos[i * 3 + 1] = (Math.random() - 0.5) * 40;
        pos[i * 3 + 2] = -Math.random() * 200;
      }
      starField.geometry.attributes.position.needsUpdate = true;

      rowNotice.textContent = '';
      rowNotice.classList.add('opacity-0');
      rowNotice.classList.remove('opacity-100');

      scoreBoard.textContent = `Lvl ${level} • Score: ${score} • Lasers: ${laserAmmo}/${LASER_MAX}`;
      gameOverModal.style.display = 'none';
      instructions.style.display = 'block';
    }

    function onResize() {
      const w = gameContainer.clientWidth, h = gameContainer.clientHeight;
      camera.aspect = w / h; camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
  </script>
</body>
</html>
